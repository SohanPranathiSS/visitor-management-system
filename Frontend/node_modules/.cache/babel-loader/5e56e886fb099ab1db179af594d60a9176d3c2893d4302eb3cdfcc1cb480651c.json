{"ast":null,"code":"// The base URL for your backend API\nconst API_BASE_URL = 'http://localhost:4000/api';\n\n/**\r\n * A centralized request function to handle all API calls.\r\n * It automatically adds the JWT Authorization header if a token exists.\r\n * @param {string} endpoint - The API endpoint to call (e.g., '/login').\r\n * @param {object} options - Configuration for the fetch request (method, body, etc.).\r\n * @returns {Promise<any>} The JSON response from the server.\r\n * @throws {Error} Throws an error if the network request fails or the server returns an error.\r\n */\nconst request = async (endpoint, options = {}) => {\n  // Retrieve the token from local storage on each request\n  const token = localStorage.getItem('token');\n  const headers = {\n    'Content-Type': 'application/json',\n    ...options.headers\n  };\n\n  // If a token exists, add it to the Authorization header\n  if (token) {\n    headers['Authorization'] = `Bearer ${token}`;\n  }\n  try {\n    const response = await fetch(`${API_BASE_URL}${endpoint}`, {\n      ...options,\n      headers\n    });\n\n    // Handle cases where the server might not return JSON (e.g., server down)\n    const contentType = response.headers.get('content-type');\n    if (!contentType || !contentType.includes('application/json')) {\n      // Attempt to get text for better error logging\n      const errorText = await response.text();\n      console.error(\"Server returned a non-JSON response:\", errorText);\n      throw new Error('Server response was not in the expected JSON format.');\n    }\n    const responseData = await response.json();\n    if (!response.ok) {\n      // Use the server's error message if available, otherwise a generic one\n      throw new Error(responseData.message || 'An unknown API error occurred.');\n    }\n    return responseData;\n  } catch (error) {\n    console.error(`API request to ${endpoint} failed:`, error);\n    // Re-throw the error so it can be caught by the calling component (e.g., in a try/catch block)\n    throw error;\n  }\n};\n\n/**\r\n * Logs in a user.\r\n * @param {string} email - The user's email.\r\n * @param {string} password - The user's password.\r\n */\nexport const loginUser = (email, password) => {\n  return request('/login', {\n    method: 'POST',\n    body: JSON.stringify({\n      email,\n      password\n    })\n  });\n};\n\n/**\r\n * **FIXED**: This function is for the public-facing registration page.\r\n * It assumes the page provides separate firstName and lastName fields.\r\n * @param {object} userData - Raw user data, expected to include { firstName, lastName, email, password }.\r\n */\nexport const registerUser = userData => {\n  return request('/register', {\n    method: 'POST',\n    body: JSON.stringify(userData)\n  });\n};\n\n/**\r\n * **NEW**: This function is for the company registration page.\r\n * It sends all form data to the new company registration endpoint.\r\n * @param {object} companyData - Raw form data from the RegistrationPage.\r\n */\nexport const registerCompany = companyData => {\n  return request('/registerCompany', {\n    method: 'POST',\n    body: JSON.stringify(companyData)\n  });\n};\n\n/**\r\n * This function is for the Admin Dashboard to create hosts from a single 'name' field.\r\n * It correctly structures the name into firstName and lastName for the backend.\r\n * @param {object} userData - Must contain name, email, and password.\r\n */\nexport const createUser = userData => {\n  const [firstName, ...lastNameParts] = userData.name.split(' ');\n  const lastName = lastNameParts.join(' ');\n  const registrationData = {\n    firstName,\n    lastName,\n    email: userData.email,\n    password: userData.password\n  };\n  return request('/register', {\n    method: 'POST',\n    body: JSON.stringify(registrationData)\n  });\n};\n\n/**\r\n * Fetches all users (admin only).\r\n */\nexport const getUsers = () => {\n  return request('/users');\n};\n\n/**\r\n * Fetches visits based on the user's role.\r\n * - 'admin' role fetches from /visits and can use all filters.\r\n * - 'host' role fetches from /host-visits.\r\n * @param {string} role - The role of the logged-in user ('admin' or 'host').\r\n * @param {object} filters - Optional filters for the query (e.g., { hostName: 'John' }).\r\n */\nexport const getVisits = (role, filters = {}) => {\n  const params = new URLSearchParams(filters);\n\n  // Choose the correct endpoint based on the user's role\n  const endpoint = role === 'admin' ? '/visits' : '/host-visits';\n  return request(`${endpoint}?${params.toString()}`);\n};\n\n/**\r\n * Creates a new visit record (check-in).\r\n * @param {object} checkInData - The data for the new visit.\r\n */\nexport const checkInVisitor = checkInData => {\n  return request('/visits', {\n    method: 'POST',\n    body: JSON.stringify(checkInData)\n  });\n};\n\n/**\r\n * Checks out a visit.\r\n * @param {number|string} visitId - The ID of the visit to check out.\r\n */\nexport const checkOutVisit = visitId => {\n  return request(`/visits/${visitId}/checkout`, {\n    method: 'PUT'\n  });\n};","map":{"version":3,"names":["API_BASE_URL","request","endpoint","options","token","localStorage","getItem","headers","response","fetch","contentType","get","includes","errorText","text","console","error","Error","responseData","json","ok","message","loginUser","email","password","method","body","JSON","stringify","registerUser","userData","registerCompany","companyData","createUser","firstName","lastNameParts","name","split","lastName","join","registrationData","getUsers","getVisits","role","filters","params","URLSearchParams","toString","checkInVisitor","checkInData","checkOutVisit","visitId"],"sources":["C:/Users/sohan/Desktop/Working/Visitor_management (Working on registration)/Frontend/src/utils/apiService.js"],"sourcesContent":["// The base URL for your backend API\r\nconst API_BASE_URL = 'http://localhost:4000/api';\r\n\r\n/**\r\n * A centralized request function to handle all API calls.\r\n * It automatically adds the JWT Authorization header if a token exists.\r\n * @param {string} endpoint - The API endpoint to call (e.g., '/login').\r\n * @param {object} options - Configuration for the fetch request (method, body, etc.).\r\n * @returns {Promise<any>} The JSON response from the server.\r\n * @throws {Error} Throws an error if the network request fails or the server returns an error.\r\n */\r\nconst request = async (endpoint, options = {}) => {\r\n  // Retrieve the token from local storage on each request\r\n  const token = localStorage.getItem('token');\r\n  const headers = {\r\n    'Content-Type': 'application/json',\r\n    ...options.headers,\r\n  };\r\n  \r\n  // If a token exists, add it to the Authorization header\r\n  if (token) {\r\n    headers['Authorization'] = `Bearer ${token}`;\r\n  }\r\n\r\n  try {\r\n    const response = await fetch(`${API_BASE_URL}${endpoint}`, { ...options, headers });\r\n\r\n    // Handle cases where the server might not return JSON (e.g., server down)\r\n    const contentType = response.headers.get('content-type');\r\n    if (!contentType || !contentType.includes('application/json')) {\r\n        // Attempt to get text for better error logging\r\n        const errorText = await response.text();\r\n        console.error(\"Server returned a non-JSON response:\", errorText);\r\n        throw new Error('Server response was not in the expected JSON format.');\r\n    }\r\n\r\n    const responseData = await response.json();\r\n\r\n    if (!response.ok) {\r\n        // Use the server's error message if available, otherwise a generic one\r\n        throw new Error(responseData.message || 'An unknown API error occurred.');\r\n    }\r\n\r\n    return responseData;\r\n  } catch (error) {\r\n    console.error(`API request to ${endpoint} failed:`, error);\r\n    // Re-throw the error so it can be caught by the calling component (e.g., in a try/catch block)\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Logs in a user.\r\n * @param {string} email - The user's email.\r\n * @param {string} password - The user's password.\r\n */\r\nexport const loginUser = (email, password) => {\r\n  return request('/login', {\r\n    method: 'POST',\r\n    body: JSON.stringify({ email, password }),\r\n  });\r\n};\r\n\r\n/**\r\n * **FIXED**: This function is for the public-facing registration page.\r\n * It assumes the page provides separate firstName and lastName fields.\r\n * @param {object} userData - Raw user data, expected to include { firstName, lastName, email, password }.\r\n */\r\nexport const registerUser = (userData) => {\r\n  return request('/register', {\r\n    method: 'POST',\r\n    body: JSON.stringify(userData),\r\n  });\r\n};\r\n\r\n/**\r\n * **NEW**: This function is for the company registration page.\r\n * It sends all form data to the new company registration endpoint.\r\n * @param {object} companyData - Raw form data from the RegistrationPage.\r\n */\r\nexport const registerCompany = (companyData) => {\r\n    return request('/registerCompany', {\r\n        method: 'POST',\r\n        body: JSON.stringify(companyData),\r\n    });\r\n};\r\n\r\n\r\n/**\r\n * This function is for the Admin Dashboard to create hosts from a single 'name' field.\r\n * It correctly structures the name into firstName and lastName for the backend.\r\n * @param {object} userData - Must contain name, email, and password.\r\n */\r\nexport const createUser = (userData) => {\r\n  const [firstName, ...lastNameParts] = userData.name.split(' ');\r\n  const lastName = lastNameParts.join(' ');\r\n\r\n  const registrationData = {\r\n    firstName,\r\n    lastName,\r\n    email: userData.email,\r\n    password: userData.password,\r\n  };\r\n\r\n  return request('/register', {\r\n    method: 'POST',\r\n    body: JSON.stringify(registrationData),\r\n  });\r\n};\r\n\r\n/**\r\n * Fetches all users (admin only).\r\n */\r\nexport const getUsers = () => {\r\n  return request('/users');\r\n};\r\n\r\n/**\r\n * Fetches visits based on the user's role.\r\n * - 'admin' role fetches from /visits and can use all filters.\r\n * - 'host' role fetches from /host-visits.\r\n * @param {string} role - The role of the logged-in user ('admin' or 'host').\r\n * @param {object} filters - Optional filters for the query (e.g., { hostName: 'John' }).\r\n */\r\nexport const getVisits = (role, filters = {}) => {\r\n  const params = new URLSearchParams(filters);\r\n  \r\n  // Choose the correct endpoint based on the user's role\r\n  const endpoint = role === 'admin' ? '/visits' : '/host-visits';\r\n\r\n  return request(`${endpoint}?${params.toString()}`);\r\n};\r\n\r\n/**\r\n * Creates a new visit record (check-in).\r\n * @param {object} checkInData - The data for the new visit.\r\n */\r\nexport const checkInVisitor = (checkInData) => {\r\n  return request('/visits', {\r\n    method: 'POST',\r\n    body: JSON.stringify(checkInData),\r\n  });\r\n};\r\n\r\n/**\r\n * Checks out a visit.\r\n * @param {number|string} visitId - The ID of the visit to check out.\r\n */\r\nexport const checkOutVisit = (visitId) => {\r\n  return request(`/visits/${visitId}/checkout`, {\r\n    method: 'PUT',\r\n  });\r\n};\r\n"],"mappings":"AAAA;AACA,MAAMA,YAAY,GAAG,2BAA2B;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,OAAO,GAAG,MAAAA,CAAOC,QAAQ,EAAEC,OAAO,GAAG,CAAC,CAAC,KAAK;EAChD;EACA,MAAMC,KAAK,GAAGC,YAAY,CAACC,OAAO,CAAC,OAAO,CAAC;EAC3C,MAAMC,OAAO,GAAG;IACd,cAAc,EAAE,kBAAkB;IAClC,GAAGJ,OAAO,CAACI;EACb,CAAC;;EAED;EACA,IAAIH,KAAK,EAAE;IACTG,OAAO,CAAC,eAAe,CAAC,GAAG,UAAUH,KAAK,EAAE;EAC9C;EAEA,IAAI;IACF,MAAMI,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAGT,YAAY,GAAGE,QAAQ,EAAE,EAAE;MAAE,GAAGC,OAAO;MAAEI;IAAQ,CAAC,CAAC;;IAEnF;IACA,MAAMG,WAAW,GAAGF,QAAQ,CAACD,OAAO,CAACI,GAAG,CAAC,cAAc,CAAC;IACxD,IAAI,CAACD,WAAW,IAAI,CAACA,WAAW,CAACE,QAAQ,CAAC,kBAAkB,CAAC,EAAE;MAC3D;MACA,MAAMC,SAAS,GAAG,MAAML,QAAQ,CAACM,IAAI,CAAC,CAAC;MACvCC,OAAO,CAACC,KAAK,CAAC,sCAAsC,EAAEH,SAAS,CAAC;MAChE,MAAM,IAAII,KAAK,CAAC,sDAAsD,CAAC;IAC3E;IAEA,MAAMC,YAAY,GAAG,MAAMV,QAAQ,CAACW,IAAI,CAAC,CAAC;IAE1C,IAAI,CAACX,QAAQ,CAACY,EAAE,EAAE;MACd;MACA,MAAM,IAAIH,KAAK,CAACC,YAAY,CAACG,OAAO,IAAI,gCAAgC,CAAC;IAC7E;IAEA,OAAOH,YAAY;EACrB,CAAC,CAAC,OAAOF,KAAK,EAAE;IACdD,OAAO,CAACC,KAAK,CAAC,kBAAkBd,QAAQ,UAAU,EAAEc,KAAK,CAAC;IAC1D;IACA,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMM,SAAS,GAAGA,CAACC,KAAK,EAAEC,QAAQ,KAAK;EAC5C,OAAOvB,OAAO,CAAC,QAAQ,EAAE;IACvBwB,MAAM,EAAE,MAAM;IACdC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;MAAEL,KAAK;MAAEC;IAAS,CAAC;EAC1C,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMK,YAAY,GAAIC,QAAQ,IAAK;EACxC,OAAO7B,OAAO,CAAC,WAAW,EAAE;IAC1BwB,MAAM,EAAE,MAAM;IACdC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAACE,QAAQ;EAC/B,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,eAAe,GAAIC,WAAW,IAAK;EAC5C,OAAO/B,OAAO,CAAC,kBAAkB,EAAE;IAC/BwB,MAAM,EAAE,MAAM;IACdC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAACI,WAAW;EACpC,CAAC,CAAC;AACN,CAAC;;AAGD;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,UAAU,GAAIH,QAAQ,IAAK;EACtC,MAAM,CAACI,SAAS,EAAE,GAAGC,aAAa,CAAC,GAAGL,QAAQ,CAACM,IAAI,CAACC,KAAK,CAAC,GAAG,CAAC;EAC9D,MAAMC,QAAQ,GAAGH,aAAa,CAACI,IAAI,CAAC,GAAG,CAAC;EAExC,MAAMC,gBAAgB,GAAG;IACvBN,SAAS;IACTI,QAAQ;IACRf,KAAK,EAAEO,QAAQ,CAACP,KAAK;IACrBC,QAAQ,EAAEM,QAAQ,CAACN;EACrB,CAAC;EAED,OAAOvB,OAAO,CAAC,WAAW,EAAE;IAC1BwB,MAAM,EAAE,MAAM;IACdC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAACY,gBAAgB;EACvC,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMC,QAAQ,GAAGA,CAAA,KAAM;EAC5B,OAAOxC,OAAO,CAAC,QAAQ,CAAC;AAC1B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMyC,SAAS,GAAGA,CAACC,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,KAAK;EAC/C,MAAMC,MAAM,GAAG,IAAIC,eAAe,CAACF,OAAO,CAAC;;EAE3C;EACA,MAAM1C,QAAQ,GAAGyC,IAAI,KAAK,OAAO,GAAG,SAAS,GAAG,cAAc;EAE9D,OAAO1C,OAAO,CAAC,GAAGC,QAAQ,IAAI2C,MAAM,CAACE,QAAQ,CAAC,CAAC,EAAE,CAAC;AACpD,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMC,cAAc,GAAIC,WAAW,IAAK;EAC7C,OAAOhD,OAAO,CAAC,SAAS,EAAE;IACxBwB,MAAM,EAAE,MAAM;IACdC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAACqB,WAAW;EAClC,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa,GAAIC,OAAO,IAAK;EACxC,OAAOlD,OAAO,CAAC,WAAWkD,OAAO,WAAW,EAAE;IAC5C1B,MAAM,EAAE;EACV,CAAC,CAAC;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}